#ifndef VEC_3_H
#define VEC_3_H

#include <iostream>
#include <cmath>

namespace lito {

template <class T>
class Vec_4;

template <class T>
class Vec_2;

template <class T>
class Vec_3 {
public:
	
	union
	{
		T coord[3];
		struct { T _x, _y, _z; };
	};

	Vec_3<T> ( T x = 0, T y = 0, T z = 0 );
	
	T&       x ();
	const T& x () const;
	T&       y ();
	const T& y () const;
	T&       z ();
	const T& z () const;
	
	T&       operator [] ( int i );
	const T& operator [] ( int i ) const;
	
	Vec_3<T>  operator + ( const Vec_3<T> &v ) const;
	Vec_3<T>  operator - ( const Vec_3<T> &v ) const;
	Vec_3<T>  operator * ( const Vec_3<T> &v ) const;
	Vec_3<T>  operator + ( T c ) const;
	Vec_3<T>  operator - ( T c ) const;
	Vec_3<T>  operator * ( T c ) const;
	Vec_3<T>  operator / ( T c ) const;
	
	Vec_3<T>& operator  = ( const Vec_3<T> &v );
	Vec_3<T>& operator += ( const Vec_3<T> &v );
	Vec_3<T>& operator -= ( const Vec_3<T> &v );
	Vec_3<T>& operator *= ( const Vec_3<T> &v );
	Vec_3<T>& operator  = ( T c );
	Vec_3<T>& operator += ( T c );
	Vec_3<T>& operator -= ( T c );
	Vec_3<T>& operator *= ( T c );
	Vec_3<T>& operator /= ( T c );
};

typedef Vec_3<float>  Vec_3f;
typedef Vec_3<double> Vec_3d;

template <class T> Vec_3<T> operator + ( const Vec_3<T> &v );
template <class T> Vec_3<T> operator - ( const Vec_3<T> &v );
template <class T> Vec_3<T> operator + ( T c, const Vec_3<T> &v );
template <class T> Vec_3<T> operator - ( T c, const Vec_3<T> &v );
template <class T> Vec_3<T> operator * ( T c, const Vec_3<T> &v );

template <class T> Vec_3<T> log ( const Vec_3<T> &v );
template <class T> Vec_3<T> pow ( const Vec_3<T> &v, T c );

template <class T> Vec_2<T>& operator << ( Vec_2<T> &vet, T dado );
template <class T> Vec_2<T>& operator ,  ( Vec_2<T> &vet, T dado );
template <class T> std::ostream& operator << ( std::ostream &os, const Vec_3<T> &v );

/*********************************************************************************************************************************/
/*********************************************************************************************************************************/
/*********************************************************************************************************************************/
/*********************************************************************************************************************************/
/*********************************************************************************************************************************/

template <class T>
Vec_3<T>::Vec_3 ( T x, T y, T z )
: _x( x )
, _y( y )
, _z( z )
{}
/*===============================================================================================================================*/
template <class T>
T& Vec_3<T>::x () { return _x; }
/*===============================================================================================================================*/
template <class T>
const T& Vec_3<T>::x () const { return _x; }
/*===============================================================================================================================*/
template <class T>
T& Vec_3<T>::y () { return _y; }
/*===============================================================================================================================*/
template <class T>
const T& Vec_3<T>::y () const { return _y; }
/*===============================================================================================================================*/
template <class T>
T& Vec_3<T>::z () { return _z; }
/*===============================================================================================================================*/
template <class T>
const T& Vec_3<T>::z () const { return _z; }
/*===============================================================================================================================*/
template <class T>
T& Vec_3<T>::operator[] ( int i ) { return coord[i]; }
/*===============================================================================================================================*/
template <class T>
const T& Vec_3<T>::operator[] ( int i ) const { return coord[i]; }
/*===============================================================================================================================*/
template <class T>
Vec_3<T> Vec_3<T>::operator + ( const Vec_3<T> &v ) const
{
	return Vec_3<T>( _x + v._x, _y + v._y, _z + v._z );
}
/*===============================================================================================================================*/
template <class T>
Vec_3<T> Vec_3<T>::operator - ( const Vec_3<T> &v ) const
{
	return Vec_3<T>( _x - v._x, _y - v._y, _z - v._z );
}
/*===============================================================================================================================*/
template <class T>
Vec_3<T> Vec_3<T>::operator * ( const Vec_3<T> &v ) const
{
	return Vec_3<T>( _x * v._x, _y * v._y, _z * v._z );
}
/*===============================================================================================================================*/
template <class T>
Vec_3<T> Vec_3<T>::operator + ( T c ) const
{
	return Vec_3<T>( _x + c, _y + c, _z + c );
}
/*===============================================================================================================================*/
template <class T>
Vec_3<T> Vec_3<T>::operator - ( T c ) const
{
	return Vec_3<T>( _x - c, _y - c, _z - c );
}
/*===============================================================================================================================*/
template <class T>
Vec_3<T> Vec_3<T>::operator * ( T c ) const
{
	return Vec_3<T>( _x * c, _y * c, _z * c );
}
/*===============================================================================================================================*/
template <class T>
Vec_3<T> Vec_3<T>::operator / ( T c ) const
{
	c = T(1) / c;
	
	return Vec_3<T>( _x * c, _y * c, _z * c );
}
/*===============================================================================================================================*/
template <class T>
Vec_3<T>& Vec_3<T>::operator = ( const Vec_3<T> &v )
{
	memcpy( coord, v.coord, sizeof(T) * 3 );
	
	return *this;
}
/*===============================================================================================================================*/
template <class T>
Vec_3<T>& Vec_3<T>::operator += ( const Vec_3<T> &v )
{
	_x += v._x;
	_y += v._y;
	_z += v._z;
	
	return *this;
}
/*===============================================================================================================================*/
template <class T>
Vec_3<T>& Vec_3<T>::operator -= ( const Vec_3<T> &v )
{
	_x -= v._x;
	_y -= v._y;
	_z -= v._z;
	
	return *this;
}
/*===============================================================================================================================*/
template <class T>
Vec_3<T>& Vec_3<T>::operator *= ( const Vec_3<T> &v )
{
	_x *= v._x;
	_y *= v._y;
	_z *= v._z;
	
	return *this;
}
/*===============================================================================================================================*/
template <class T>
Vec_3<T>& Vec_3<T>::operator  = ( T c )
{
	_z = _y = _x = c;

	return *this;
}
/*===============================================================================================================================*/
template <class T>
Vec_3<T>& Vec_3<T>::operator += ( T c )
{
	_x += c;
	_y += c;
	_z += c;
	
	return *this;
}
/*===============================================================================================================================*/
template <class T>
Vec_3<T>& Vec_3<T>::operator -= ( T c )
{
	_x -= c;
	_y -= c;
	_z -= c;
	
	return *this;
}
/*===============================================================================================================================*/
template <class T>
Vec_3<T>& Vec_3<T>::operator *= ( T c )
{
	_x *= c;
	_y *= c;
	_z *= c;
	
	return *this;
}
/*===============================================================================================================================*/
template <class T>
Vec_3<T>& Vec_3<T>::operator /= ( T c )
{
	c = T(1) / c;
	
	_x *= c;
	_y *= c;
	_z *= c;
	
	return *this;
}
/*===============================================================================================================================*/
template <class T>
Vec_3<T> operator + ( const Vec_3<T> &v )
{
	return Vec_3<T>( +v._x, +v._y, +v._z );
}
/*===============================================================================================================================*/
template <class T>
Vec_3<T> operator - ( const Vec_3<T> &v )
{
	return Vec_3<T>( -v._x, -v._y, -v._z );
}
/*===============================================================================================================================*/
template <class T>
Vec_3<T> operator + ( T c, const Vec_3<T> &v ) {
	return Vec_3<T>( c + v._x, c + v._y, c + v._z );
}
/*===============================================================================================================================*/
template <class T>
Vec_3<T> operator - ( T c, const Vec_3<T> &v ) {
	return Vec_3<T>( c - v._x, c - v._y, c - v._z );
}
/*===============================================================================================================================*/
template <class T>
Vec_3<T> operator * ( T c, const Vec_3<T> &v ) {
	return Vec_3<T>( c * v._x, c * v._y, c * v._z );
}
/*===============================================================================================================================*/
template <class T>
Vec_3<T> log ( const Vec_3<T> &v ) {
	return Vec_3<T>( std::log( v._x ), std::log( v._y ), std::log( v._z ) );
}
/*===============================================================================================================================*/
template <class T>
Vec_3<T> pow ( const Vec_3<T> &v, T c ) {
	return Vec_3<T>( std::pow( v._x, c ), std::pow( v._y, c ), std::pow( v._z, c ) );
}
/*===============================================================================================================================*/
template <class T>	
Vec_3<T>& operator << ( Vec_3<T> &vet, T dado ) {
	
	vet._x = dado;
	
	return vet;
}
/*===============================================================================================================================*/
template <class T>	
Vec_3<T>& operator , ( Vec_3<T> &vet, T dado ) {
	static size_t indice   = 1;
	static auto   id_vetor = &vet;
	
	if ( id_vetor != &vet ) {
		indice = 1;
		id_vetor = &vet;
	}
	
	switch ( indice ) {
		case 1: vet._y = dado; indice++  ; break;
		case 2: vet._z = dado; indice = 1; break;
		default: break;
	}
	
	return vet;
}
/*===============================================================================================================================*/
template <class T>
std::ostream& operator << (std::ostream &os, const Vec_3<T> &v ) {
	return os << "[ " << v._x << ", " << v._y << ", " << v._z << " ]";
}
/*===============================================================================================================================*/


}

#endif
